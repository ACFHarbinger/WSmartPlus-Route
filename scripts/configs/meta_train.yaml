# General
verbose: true
edge_t: 1.0
edge_m: "knn"
dist_m: "gmaps"
vertex_m: "mmn"

# Rwards
w_len: 1.0
w_over: 1000.0
w_waste: 100.0

# Model
embed_dim: 128
hidden_dim: 512
n_enc_l: 3
n_enc_sl: 1
n_pred_l: 2
n_dec_l: 2
n_heads: 8
norm: "instance"
acti_f: "gelu"
dropout: 0.1
agg: "sum"
agg_g: "avg"

# Optimization
optim: "rmsprop"
lr_model: 0.00005
lr_cv: 0.0001
lr_scheduler: "lambda"
lr_decay: 1.0

# Training
b_size: 256
n_data: 1280
n_val_data: 0
val_b_size: 0
bl: "exponential"
max_norm: 1.0
exp_beta: 0.8
bl_alpha: 0.05
acc_steps: 1

# Meta-RL / HRL
gat_hidden: 128
lstm_hidden: 64
gate_thresh: 0.5
meta_method: "hrl"
meta_history: 10
meta_lr: 0.000005
meta_step: 10
meta_b_size: 256
hrl_epochs: 2
hrl_clip_eps: 0.2
hrl_threshold: 0.9

# HRL Lambda
hrl_pid_target: 0.0003
hrl_lambda_waste: 300.0
hrl_lambda_cost: 0.5
hrl_lambda_overflow_init: 2000.0
hrl_lambda_overflow_min: 100.0
hrl_lambda_overflow_max: 5000.0
hrl_lambda_pruning: 0.5
hrl_lambda_mask_aux: 5.0
hrl_entropy: 0.01

# Problem
size: 100
log_step: 10
area: "riomaior"
wtype: "plastic"
f_size: 1280
val_f_size: 0
dm_method: "gmaps"
# F_GRAPH and DM_PATH are derived in script usually, providing overrides here
# Or if we want script to derive them based on SIZE/AREA loaded from YAML, we can omit them or set defaults.
# Script logic: `F_GRAPH="graphs_${SIZE}V_1N_${WTYPE}.json"`
# If YAML sets `F_GRAPH="..."`, `yaml_to_env` exports it.
# We will leave them for script to construct unless we want to hardcode specific overrides.
# But existing variable in script IS a derived default.
# I will let script construct them to allow flexibility with SIZE changes.

seed: 42
start: 0
epochs: 100
problem: "cwcvrp"
data_problem: "wcvrp"
# dataset_name and val_dataset_name derived in script

data_dists: ["gamma1"]
model_names: ["am"]
model_encoders: ["gat"]
horizon: [0, 0, 0, 0, 3]
wb_mode: "disabled"
load_path: ""
