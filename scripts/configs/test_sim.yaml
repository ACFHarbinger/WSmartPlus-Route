# General
verbose: true
n_cores: 22

# Simulation Settings
seed: 42
n_days: 31
n_bins: 100
n_samples: 1
problem: "cwcvrp"
area: "riomaior"
wtype: "plastic"
data_dist: "gamma1"

# Paths
stats_path: ""
sym_key: "skey"
env_file: "vars.env"
gp_lic_file: "gurobi.lic"
hex_dat_file: "hexaly.dat.enc"
google_api_file: "google.lic.enc"

# Policy Parameters
regular_level: [3, 4]
last_minute_cf: [70]
gurobi_param: [0.84]
hexaly_param: [0.84]
decode_type: "greedy"
lookahead_configs: ["a"]
policies: ["amgat"]

# Models (Associative Array)
model_paths:
  amgat: "" # Usually derived in script: "${PROBLEM}${N_BINS}_${AREA}_${WTYPE}/${DATA_DIST}/amgat0"
  amgat_hrl: ""
  amggac: ""
  amtgc: ""
# If we leave values empty, update script to only use YAML values if not empty?
# Actually, the script logic builds default values effectively.
# `MODEL_PATHS["amgat"]="${PROBLEM}..."`
# If we want to move this to YAML, we have to hardcode the paths OR use placeholders.
# Since paths depend on other variables (PROBLEM, N_BINS...), we cannot easily put the *logic* in YAML.
# Strategy: Only put *overrides* or static map in YAML if feasible.
# However, the user asked to move configuration to YAML.
# The dynamic construction of paths is "logic", not just "configuration".
# So, I should keep the logic in the script, or move the logic to python.
# If I put specific paths in YAML, it makes it rigid.
# Let's put the *Base* dictionary structure in YAML if possible, but empty values implies "use default logic"?
# Or, maybe the script shouldn't define `MODEL_PATHS` via hardcoded strings if we want to config it.
# BUT, recreating the bash logic `${PROBLEM}...` in YAML is impossible without evaluation.
# DECISION: I will NOT put `MODEL_PATHS` in YAML because it is dynamically constructed logic.
# I will put the *Components* (PROBLEM, AREA, etc.) in YAML, and let the script build `MODEL_PATHS`.
# UNLESS the user wants to override specific model paths.
# Let's verify `test_sim.sh` logic again.
# It defines `MODEL_PATHS` clearly.
# model_paths are constructed dynamically in the script based on problem/area variables.
# We do not define them here to avoid staleness when CLI args change.

config_paths:
  hgs: "assets/configs/lookahead_hgs.yaml"
  alns: "assets/configs/lookahead_alns.yaml"
  sans: "assets/configs/lookahead_sans.yaml"
  bcp: "assets/configs/lookahead_bcp.yaml"
  vrpp: "assets/configs/vrpp.yaml"
  lookahead_a: "assets/configs/lookahead_a.yaml"
  lookahead_b: "assets/configs/lookahead_b.yaml"

vehicles: 0
real_time_log: 1
gate_prob_threshold: "0.1"
mask_prob_threshold: "0.1"

edge_thresh: 1.0
edge_method: "knn"
vertex_method: "mmn"
dist_method: "gmaps"

checkpoints: 30
run_tsp: 1
two_opt_max_iter: 0
