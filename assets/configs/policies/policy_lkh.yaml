# @package _global_

# =============================================================================
# LKH (Lin-Kernighan-Helsgaun) TSP Solver Configuration
# =============================================================================
# PURPOSE:
#   World-class TSP solver using advanced Lin-Kernighan heuristic with
#   Helsgaun's enhancements. Produces near-optimal tours for large TSP
#   instances. Used as component in VRP solvers (via Split algorithm).
#
# ALGORITHM:
#   1. Generate initial tour (e.g., greedy, nearest neighbor)
#   2. Apply variable-depth k-opt moves (k adaptive, typically 2-5)
#   3. Use candidate sets to limit edge search space
#   4. Restart with perturbations to escape local optima
#
# CAPABILITIES:
#   - Pure TSP: Single vehicle, no capacity constraints
#   - CVRP (via Split): Transform TSP tour into feasible routes
#   - Asymmetric TSP: Handles directed graphs
#
# PERFORMANCE:
#   State-of-the-art TSP heuristic; often within 0.1% of optimal on
#   standard TSPLIB instances. Much faster than exact Concorde solver.
#
# TYPICAL USE CASES:
#   - TSP benchmark comparison (academic research)
#   - CVRP solution via "tour-first, partition-second" approach
#   - Generating high-quality initial solutions for other metaheuristics
#
# NOTE:
#   For capacitated VRP, HGS typically outperforms LKH+Split. Use LKH
#   primarily for pure TSP or as initialization method.
# =============================================================================

lkh:
  custom:
    # ---------------------------------------------------------------------
    # Capacity Handling
    # ---------------------------------------------------------------------
    - check_capacity: true
      # Enable capacity constraint checking (converts TSP to CVRP)
      # true = Use Split algorithm to partition tour into feasible routes
      # false = Return pure TSP tour (ignores vehicle capacity)
      #
      # Implementation: After LKH finds TSP tour, Split algorithm finds
      # optimal partition respecting capacity and minimizing total cost

    # ---------------------------------------------------------------------
    # Execution Control
    # ---------------------------------------------------------------------
    - max_iterations: 100
      # Maximum LKH iterations (each iteration = improve via k-opt)
      # Range: 10-1000 (10 = quick, 100 = production, 1000 = benchmark)
      # Note: LKH often converges in <50 iterations for medium instances

    # LKH parameters (implicit, from LKH library):
    #   - Initial tour: GREEDY (nearest neighbor heuristic)
    #   - Move type: 5 (up to 5-opt moves considered)
    #   - Candidate sets: Dynamic (20-50 nearest neighbors per node)
    #   - Perturbation: Enabled (random 4-opt kicks to escape local optima)
    #   - Time limit: No hard limit (controlled by max_iterations)

    # ---------------------------------------------------------------------
    # Infrastructure Settings
    # ---------------------------------------------------------------------
    - engine: "custom"
      # Execution backend: logic/src/policies/lin_kernighan.py
      # Uses LKH-3 library (http://webhotel4.ruc.dk/~keld/research/LKH-3/)

    - must_go: ["mg_lookahead.yaml"]
      # Node selection strategy for waste collection problems
      # Options: mg_lookahead.yaml, mg_last_minute_*.yaml, mg_regular.yaml
      # See: docs/MUST_GO_STRATEGIES.md

    - post_processing: []
      # LKH produces high-quality tours; further improvement usually minimal
      # Empty = use LKH output directly (optionally partitioned by Split)

    # ---------------------------------------------------------------------
    # Split Algorithm (when check_capacity: true)
    # ---------------------------------------------------------------------
    # After LKH produces giant TSP tour [depot, 5, 12, 8, ..., depot],
    # Split algorithm finds optimal partition into routes:
    #
    # Example TSP tour (100 nodes, capacity 50):
    #   [0, 45, 23, 67, 12, ..., 0]
    #
    # Split output (3 routes):
    #   Route 1: [0, 45, 23, 0] (demand: 48)
    #   Route 2: [0, 67, 12, 34, 0] (demand: 50)
    #   Route 3: [0, 89, 56, 0] (demand: 42)
    #
    # Split is polynomial-time optimal for single-vehicle partitioning.
# =============================================================================
