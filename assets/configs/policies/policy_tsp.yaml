# @package _global_

# =============================================================================
# TSP (Traveling Salesman Problem) Fast Solver Configuration
# =============================================================================
# PURPOSE:
#   Ultra-fast TSP heuristic using fast_tsp library (Python wrapper for
#   2-opt and Christofides algorithm). Ideal for real-time single-vehicle
#   routing or as initialization for multi-vehicle solvers.
#
# ALGORITHM:
#   1. Compute minimum spanning tree (Prim's algorithm)
#   2. Find Eulerian circuit in MST graph
#   3. Convert to Hamiltonian tour (Christofides heuristic)
#   4. Improve via 2-opt local search
#
# PERFORMANCE:
#   - Very fast: <0.1s for 100 nodes, <1s for 500 nodes
#   - Solution quality: Typically within 10-20% of optimal
#   - Approximation guarantee: 1.5x optimal (Christofides bound)
#
# TYPICAL USE CASES:
#   - Single-vehicle routing (no capacity constraints)
#   - Warm-start for LKH or other TSP solvers
#   - Quick baseline for benchmarking
#   - Real-time applications requiring <1s response
#
# NOTE:
#   For capacitated VRP, this policy ignores capacity. Use for pure TSP
#   only, or as initialization before Split algorithm.
# =============================================================================

tsp:
  fast_tsp:
    # ---------------------------------------------------------------------
    # Performance Optimization
    # ---------------------------------------------------------------------
    - cache: true
      # Cache distance matrix computations across multiple solves
      # true = Faster repeated calls, higher memory usage (~O(n²))
      # false = Recalculate each time, lower memory footprint
      # Recommendation: true for batch experiments, false for one-off solves

    # ---------------------------------------------------------------------
    # Node Selection Strategy
    # ---------------------------------------------------------------------
    - must_go: ["other/mg_last_minute_cf70.yaml"]
      # Pre-filter nodes before TSP solving
      # mg_last_minute_cf70.xml: Collect bins when fill ≥70% capacity
      # Alternative strategies: mg_lookahead.yaml (predictive), mg_regular.yaml
      # See: docs/MUST_GO_STRATEGIES.md
      #
      # Note: Different from most policies which use mg_lookahead.yaml
      # Last-minute strategy is simpler and faster for uncapacitated TSP

    # ---------------------------------------------------------------------
    # Runtime Control
    # ---------------------------------------------------------------------
    - time_limit: 60
      # Maximum wall-clock seconds (soft limit)
      # Range: 1-300 (fast_tsp usually finishes in <1s for 100 nodes)
      # Note: fast_tsp is so fast that time_limit rarely triggers
      #       Primarily used for consistency with other policies

    # ---------------------------------------------------------------------
    # Post-Processing
    # ---------------------------------------------------------------------
    - post_processing: []
      # Optional local search refinement after TSP
      # Empty = use fast_tsp output directly (already includes 2-opt)
      # Options: ["2opt_intra"] (redundant, fast_tsp already applies 2-opt)
      #
      # Recommendation: Empty (fast_tsp 2-opt is sufficient)

    # ---------------------------------------------------------------------
    # Algorithm Details (Implicit)
    # ---------------------------------------------------------------------
    # fast_tsp library parameters (hardcoded in logic/src/policies/single_vehicle.py):
    #   - MST algorithm: Prim's (O(n² log n))
    #   - 2-opt max iterations: 1000
    #   - 2-opt improvement threshold: 1e-6 (stop when delta < threshold)
    #   - Initial tour: MST-based Christofides construction
    #
    # Library: fast_tsp (https://github.com/fontanf/fast_tsp)
    # Underlying solver: Hybrid Christofides + 2-opt

    # ---------------------------------------------------------------------
    # Use Cases and Limitations
    # ---------------------------------------------------------------------
    # GOOD FOR:
    #   - Pure TSP (single vehicle, no capacity)
    #   - Real-time routing (sub-second response)
    #   - Warm-starting more sophisticated solvers
    #
    # NOT SUITABLE FOR:
    #   - Capacitated VRP (ignores vehicle capacity)
    #   - Near-optimal solutions (10-20% gap typical)
    #   - Large instances >1000 nodes (use LKH instead)
    #
    # INTEGRATION WITH CVRP:
    #   For capacity-aware routing, consider:
    #   1. Use fast_tsp to get quick TSP tour
    #   2. Apply Split algorithm to partition into feasible routes
    #   3. Refine with local search (relocate, swap)
    #   However, direct CVRP solvers (HGS, ALNS) usually outperform this.
# =============================================================================
